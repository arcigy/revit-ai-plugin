# ğŸ§© 1.1 User Interface (UI Layer)

## ğŸ¯ Purpose
The UI layer is the main user-facing interface of the Revit AI plugin.  
It allows the user to:
- enter text commands for the AI,
- upload an image for visual context,
- use the current Revit element selection,
- and provide feedback after an action is executed.

This layer connects the user directly to the AI backend, which interprets the input and returns actionable instructions for the Revit API.

---

## ğŸ§± Component Structure

| Component | Description | Type |
|------------|--------------|------|
| `CommandWindow.xaml` | Main plugin window | WPF Window |
| `CommandWindow.xaml.cs` | Logic for UI events and request handling | C# Code-behind |
| `FeedbackDialog.xaml` | Post-execution feedback dialog | WPF Dialog |
| `DockablePanel` | (optional) docked panel version inside Revit | `IDockablePaneProvider` |
| `Resources/Icons/` | Button icons | PNG / SVG |

---

## ğŸ§­ Layout

The interface is divided into four main sections:

+------------------------------------------------------+
| ğŸ§  AI COMMAND |
| [TextBox] â†’ Type your AI command |
| [Button Execute] |
| |
| ğŸ“¸ CONTEXT IMAGE |
| [Button Upload Image] [Label] selected_image.jpg |
| |
| ğŸ¯ REVIT SELECTION |
| [Button Use Selected Elements] |
| [Label] 3 elements selected |
| |
| ğŸ§¾ FEEDBACK (appears after execution) |
| [Yes] [No] [Add Note] |
+------------------------------------------------------+

yaml


---

## ğŸ§© Functionality

### 1. Command Input
- A simple `TextBox` for entering text commands.  
- `Execute` button triggers the main pipeline:
  - reads the text input,
  - attaches the current context (active view, selection, image),
  - sends the JSON payload to the backend.

---

### 2. Image Upload
- `Upload Image` opens a file picker (`OpenFileDialog`).  
- The selected image is encoded in Base64 and stored in `_currentImage`.  
- The file name is displayed in the UI.  
- The Base64 string is sent to the backend inside the `image_context` field.

**C# Example:**
```csharp
private void BtnUploadImage_Click(object sender, RoutedEventArgs e)
{
    OpenFileDialog dlg = new OpenFileDialog();
    dlg.Filter = "Images|*.jpg;*.jpeg;*.png";
    if (dlg.ShowDialog() == true)
    {
        string path = dlg.FileName;
        byte[] imageBytes = File.ReadAllBytes(path);
        string base64 = Convert.ToBase64String(imageBytes);

        _currentImage = new ImageContext
        {
            Filename = Path.GetFileName(path),
            Base64 = base64
        };

        lblImageName.Content = Path.GetFileName(path);
    }
}
3. Using Revit Selection
Use Selected Elements retrieves the current selection from Revit.

It extracts element IDs, categories, and names.

Stores them in _selectedElements and updates the label count.

C# Example:

csharp

private void BtnUseSelected_Click(object sender, RoutedEventArgs e)
{
    UIDocument uidoc = new UIDocument(DocumentManager.Instance.CurrentDBDocument);
    ICollection<ElementId> ids = uidoc.Selection.GetElementIds();

    var selectedElements = ids.Select(id => {
        Element e = uidoc.Document.GetElement(id);
        return new {
            id = id.IntegerValue,
            category = e.Category?.Name,
            name = e.Name
        };
    }).ToList();

    _selectedElements = selectedElements;
    lblSelectionCount.Content = $"{selectedElements.Count} elements selected";
}
4. Execute Command
When Execute is pressed:

A JSON payload is constructed:

json

{
  "command": "create section through selected stairs",
  "context": {
    "active_view": "Floor Plan - Level 1",
    "selected_elements": [...]
  },
  "image_context": {
    "filename": "stairs.jpg",
    "base64": "iVBORw0KGgoAAA..."
  }
}
Itâ€™s sent to the backend via BackendService.SendRequestAsync(payload).

The UI shows a loading spinner until a response is received.

C# Example:

csharp

private async void BtnExecute_Click(object sender, RoutedEventArgs e)
{
    var payload = new {
        command = txtCommand.Text,
        context = new {
            active_view = doc.ActiveView.Name,
            selected_elements = _selectedElements
        },
        image_context = _currentImage
    };

    var response = await BackendService.SendRequestAsync(payload);
    FeedbackDialog.Show(response);
}
5. Post-Execution Feedback
After the backend response is executed:

The dialog asks: â€œWas this done correctly?â€

Buttons: [âœ… Yes], [âŒ No], [ğŸ“ Add Note]

The feedback is sent back to /api/feedback.

C# Example:

csharp

FeedbackResult feedback = FeedbackDialog.Show();
await BackendService.SendFeedbackAsync(new {
    command = txtCommand.Text,
    success = feedback.IsSuccess,
    note = feedback.Note
});
ğŸ§© Classes and Models
Class	Purpose
CommandWindow	Main WPF window
ImageContext	Holds image filename + Base64 string
BackendService	Handles HTTP requests to AI backend
FeedbackDialog	Collects user feedback
SelectionContext	Stores selected element metadata

âš ï¸ Key Risks
Threading â€“ all Revit API calls must use ExternalEvent.

Async Behavior â€“ UI must remain responsive (async/await).

Image Size â€“ resize before Base64 (max 512px per side).

Empty Selection â€“ warn if user runs command requiring selection.

Input Validation â€“ check for empty text, invalid JSON, or missing elements.

ğŸ§­ Future Enhancements
Recent command history dropdown

Drag & Drop image upload

Local auto-suggestion of frequent commands

Voice input for hands-free operation

ğŸ“¦ Folder Structure
lua

/UI
  â”œâ”€â”€ CommandWindow.xaml
  â”œâ”€â”€ CommandWindow.xaml.cs
  â”œâ”€â”€ FeedbackDialog.xaml
  â”œâ”€â”€ FeedbackDialog.xaml.cs
  â”œâ”€â”€ /Resources
  â”‚     â”œâ”€â”€ execute.png
  â”‚     â”œâ”€â”€ upload.png
  â”‚     â””â”€â”€ select.png
  â””â”€â”€ ViewModels/
         â””â”€â”€ CommandViewModel.cs
âœ… Outcome
After implementing this component, the user can:

enter text prompts for the AI,

provide visual context through an uploaded image,

use selected Revit elements as context,

execute full AI-driven workflows,

and give feedback to continuously improve the system.

All directly inside the Revit environment â€” without leaving the design workspace