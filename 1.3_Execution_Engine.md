# 1.3 Execution Engine

## üéØ Purpose
The Execution Engine is responsible for **executing the workflow JSON returned by the AI backend** inside Revit.  
It acts as the final layer in the frontend: taking validated, structured commands and performing the actual Revit API operations safely and deterministically.

---

## üß± Component Structure

| Component | Description | Type |
|------------|------------|------|
| `ExecutionEngine.cs` | Core engine to interpret workflow JSON and run actions | C# Class |
| `ActionRegistry.cs` | Stores all available action types and their execution methods | C# Class |
| `ActionStep.cs` | Model representing each step in the workflow | C# Class |
| `ExternalEventWrapper.cs` | Wraps Revit API calls in `ExternalEvent` for thread safety | C# Class |
| `Logger.cs` | Optional logging of executed actions | C# Class |

---

## üß≠ Workflow Overview

[CommandHandler.HandleResponse()]
‚îÇ
‚ñº
[ExecutionEngine.ExecuteWorkflow(Workflow JSON)]
‚îÇ
‚ñº
[Iterate Action Steps]
‚îÇ
‚ñº
[Lookup Action in ActionRegistry]
‚îÇ
‚ñº
[Execute Action via ExternalEventWrapper]
‚îÇ
‚ñº
[Log Success / Errors]
‚îÇ
‚ñº
[Return Feedback to CommandHandler]



---

## üß© Functionality

### 1. Workflow Execution

- Receives `Workflow` object from `CommandResponse`.
- Iterates through each `ActionStep` in order.
- Checks if the action exists in `ActionRegistry`.
- Executes the action safely in Revit context using `ExternalEvent`.

**C# Example:**
```csharp
public void ExecuteWorkflow(Workflow workflow)
{
    foreach (var step in workflow.Steps)
    {
        if (!ActionRegistry.HasAction(step.Command))
        {
            MessageBox.Show($"Unknown action: {step.Command}");
            continue;
        }

        var action = ActionRegistry.GetAction(step.Command);
        ExternalEventWrapper.Run(() => action.Execute(step.Parameters));
    }
}
2. Action Registry
A central store of all available Revit actions that the plugin can perform.

Maps action names (from AI JSON) to concrete C# methods.

C# Example:

public static class ActionRegistry
{
    private static Dictionary<string, IRevitAction> _actions = new Dictionary<string, IRevitAction>();

    public static void Register(string name, IRevitAction action)
    {
        _actions[name] = action;
    }

    public static bool HasAction(string name) => _actions.ContainsKey(name);

    public static IRevitAction GetAction(string name) => _actions[name];
}
3. ExternalEvent Wrapper
Ensures all Revit API calls run on the main thread (required by Revit).

Wraps each action execution in an ExternalEvent handler.

C# Example:

public static class ExternalEventWrapper
{
    public static void Run(Action action)
    {
        var handler = new RevitExternalEventHandler(action);
        ExternalEvent exEvent = ExternalEvent.Create(handler);
        exEvent.Raise();
    }
}

public class RevitExternalEventHandler : IExternalEventHandler
{
    private readonly Action _action;

    public RevitExternalEventHandler(Action action)
    {
        _action = action;
    }

    public void Execute(UIApplication app)
    {
        try
        {
            _action.Invoke();
        }
        catch (Exception ex)
        {
            MessageBox.Show($"Error executing action: {ex.Message}");
        }
    }

    public string GetName() => "RevitExecutionHandler";
}
4. Example Actions
Example: Create Section View for Selected Stairs

public class CreateSectionAction : IRevitAction
{
    public void Execute(Dictionary<string, object> parameters)
    {
        var elementId = (int)parameters["elementId"];
        var doc = DocumentManager.Instance.CurrentDBDocument;
        var element = doc.GetElement(new ElementId(elementId));

        if (element is Stairs stairs)
        {
            using (Transaction t = new Transaction(doc, "Create Section"))
            {
                t.Start();
                ViewSection.CreateSection(doc, stairs);
                t.Commit();
            }
        }
    }
}
Example: Dimension All Walls

public class DimensionWallsAction : IRevitAction
{
    public void Execute(Dictionary<string, object> parameters)
    {
        var doc = DocumentManager.Instance.CurrentDBDocument;
        var walls = new FilteredElementCollector(doc)
            .OfClass(typeof(Wall))
            .ToElements();

        using (Transaction t = new Transaction(doc, "Dimension Walls"))
        {
            t.Start();
            foreach (var wall in walls)
            {
                DimensionUtils.CreateDimensionForElement(doc, wall);
            }
            t.Commit();
        }
    }
}
5. Logging & Error Handling
Optional logging of each executed action and parameters.

Captures errors and sends them back to Command Handler for user feedback.

Can be stored locally or sent to Supabase for future AI memory.

C# Example:

public static class Logger
{
    public static void LogAction(string actionName, Dictionary<string, object> parameters)
    {
        // Example: write to file or console
        Debug.WriteLine($"Action: {actionName}, Params: {JsonConvert.SerializeObject(parameters)}");
    }

    public static void LogError(string actionName, string error)
    {
        Debug.WriteLine($"Error in {actionName}: {error}");
    }
}
‚ö†Ô∏è Key Considerations
Revit API Threading: All API calls must use ExternalEvent.

Transactions: Each action that modifies Revit must use Transaction.

Validation: Ensure elements exist before executing actions.

Error Reporting: Fail gracefully if the AI returns invalid workflow JSON.

Extensibility: Actions should be modular; new action types can be added to ActionRegistry without changing the engine.

üì¶ Suggested File Structure

/Frontend
  ‚îú‚îÄ‚îÄ ExecutionEngine.cs
  ‚îú‚îÄ‚îÄ ActionRegistry.cs
  ‚îú‚îÄ‚îÄ ExternalEventWrapper.cs
  ‚îú‚îÄ‚îÄ Logger.cs
  ‚îî‚îÄ‚îÄ Models/
        ‚îî‚îÄ‚îÄ ActionStep.cs
‚úÖ Objective
After implementing the Execution Engine:

Workflow JSON from AI is safely executed inside Revit.

All actions are modular, logged, and wrapped in transactions.

Errors are caught and returned for user feedback.

New actions can be added without changing core engine.

System is ready to integrate with the Command Handler and UI for a complete front-to-back plugin workflow.