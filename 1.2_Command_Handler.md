# 1.2 Command Handler

## üéØ Purpose
The Command Handler is responsible for **processing user input** from the UI, validating it, constructing the JSON payload, sending it to the backend AI service, and handling the response.  
It acts as the **bridge between the frontend UI layer and the execution engine**, ensuring that user commands are safe, complete, and actionable.

---

## üß± Component Structure

| Component | Description | Type |
|------------|------------|------|
| `CommandHandler.cs` | Main handler for commands from UI | C# Class |
| `PayloadBuilder.cs` | Constructs structured JSON for backend | C# Class |
| `BackendService.cs` | Sends requests to AI backend and handles responses | C# Class |
| `CommandValidator.cs` | Validates text input, selection, and image context | C# Class |
| `Models/CommandRequest.cs` | DTO for command request payload | C# Class |
| `Models/CommandResponse.cs` | DTO for AI workflow response | C# Class |

---

## üß≠ Flow Overview

[UI Event: Execute Button Clicked]
‚îÇ
‚ñº
[CommandHandler.ValidateInput()]
‚îÇ
‚ñº
[PayloadBuilder.BuildPayload()]
‚îÇ
‚ñº
[BackendService.SendRequestAsync()]
‚îÇ
‚ñº
[CommandHandler.HandleResponse()]
‚îÇ
‚ñº
[ExecutionEngine.ExecuteWorkflow()]
‚îÇ
‚ñº
[FeedbackDialog.Show()]
‚îÇ
‚ñº
[BackendService.SendFeedbackAsync()]

csharp


---

## üß© Functionality

### 1. Input Validation
- Ensures that:
  - Command text is not empty.
  - If required, selected elements exist.
  - Uploaded images are valid format (`jpg`, `png`) and size < 512px per side.
- Returns errors to the user via popup if validation fails.

**C# Example:**
```csharp
public bool ValidateInput(string command, List<Element> selectedElements, ImageContext image)
{
    if (string.IsNullOrWhiteSpace(command))
    {
        MessageBox.Show("Command cannot be empty.");
        return false;
    }

    if (commandRequiresSelection(command) && (selectedElements == null || selectedElements.Count == 0))
    {
        MessageBox.Show("You must select elements for this command.");
        return false;
    }

    if (image != null && !IsValidImage(image))
    {
        MessageBox.Show("Uploaded image is invalid or too large.");
        return false;
    }

    return true;
}
2. Payload Construction
Creates a strongly-typed object that represents the command, context, selection, and image.

Converts the object into JSON before sending it to the backend.

C# Example:

csharp

public CommandRequest BuildPayload(string command, string activeView, List<SelectedElement> selection, ImageContext image)
{
    return new CommandRequest
    {
        CommandText = command,
        Context = new Context
        {
            ActiveView = activeView,
            SelectedElements = selection
        },
        ImageContext = image
    };
}
3. Backend Communication
Sends POST request to AI backend (FastAPI on Railway.com).

Handles network errors, timeouts, and unexpected responses.

Parses JSON response into CommandResponse object.

C# Example:

csharp

public async Task<CommandResponse> SendRequestAsync(CommandRequest payload)
{
    string json = JsonConvert.SerializeObject(payload);
    var content = new StringContent(json, Encoding.UTF8, "application/json");

    try
    {
        HttpResponseMessage response = await _httpClient.PostAsync(_backendUrl + "/api/interpret", content);
        response.EnsureSuccessStatusCode();
        string responseJson = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<CommandResponse>(responseJson);
    }
    catch (Exception ex)
    {
        MessageBox.Show($"Error communicating with backend: {ex.Message}");
        return null;
    }
}
4. Response Handling
After receiving workflow JSON, the handler forwards it to the Execution Engine.

If the response contains errors, it displays them to the user.

Optionally logs the workflow for debugging or future AI memory.

C# Example:

csharp

public void HandleResponse(CommandResponse response)
{
    if (response == null)
    {
        MessageBox.Show("No response from AI backend.");
        return;
    }

    if (response.Errors.Any())
    {
        MessageBox.Show("AI workflow errors: " + string.Join(", ", response.Errors));
        return;
    }

    ExecutionEngine.ExecuteWorkflow(response.Workflow);
}
5. Feedback Loop
After execution, the handler collects user feedback:

Was the action correct?

Optional notes.

Sends feedback back to the backend (/api/feedback) to update Supabase memory.

C# Example:

csharp

public async Task SendFeedbackAsync(string command, bool success, string note)
{
    var feedback = new FeedbackRequest
    {
        CommandText = command,
        Success = success,
        Note = note
    };

    string json = JsonConvert.SerializeObject(feedback);
    await _httpClient.PostAsync(_backendUrl + "/api/feedback", new StringContent(json, Encoding.UTF8, "application/json"));
}
üß© Data Models
CommandRequest
csharp

public class CommandRequest
{
    public string CommandText { get; set; }
    public Context Context { get; set; }
    public ImageContext ImageContext { get; set; }
}

public class Context
{
    public string ActiveView { get; set; }
    public List<SelectedElement> SelectedElements { get; set; }
}

public class SelectedElement
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Category { get; set; }
}
CommandResponse
csharp

public class CommandResponse
{
    public Workflow Workflow { get; set; }
    public List<string> Errors { get; set; }
}

public class Workflow
{
    public List<ActionStep> Steps { get; set; }
}

public class ActionStep
{
    public string Command { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
}
FeedbackRequest
csharp

public class FeedbackRequest
{
    public string CommandText { get; set; }
    public bool Success { get; set; }
    public string Note { get; set; }
}
‚ö†Ô∏è Key Considerations
Thread Safety: All Revit API calls must use ExternalEvent to run on the main thread.

Async Handling: Use async/await to avoid freezing UI during backend calls.

Validation: Always validate input before sending requests.

Error Logging: Capture network errors, invalid JSON, and AI workflow errors.

Extensibility: Command handler should support adding new input types or context fields in the future.

üì¶ Suggested File Structure
markdown

/Frontend
  ‚îú‚îÄ‚îÄ CommandHandler.cs
  ‚îú‚îÄ‚îÄ PayloadBuilder.cs
  ‚îú‚îÄ‚îÄ BackendService.cs
  ‚îú‚îÄ‚îÄ CommandValidator.cs
  ‚îî‚îÄ‚îÄ Models/
        ‚îú‚îÄ‚îÄ CommandRequest.cs
        ‚îú‚îÄ‚îÄ CommandResponse.cs
        ‚îî‚îÄ‚îÄ FeedbackRequest.cs
‚úÖ Objective
After implementing the Command Handler:

All UI commands are validated and safely sent to the AI backend.

Responses are parsed and executed in Revit.

Feedback is collected and persisted in Supabase for AI memory.

The system is modular, maintainable, and ready to integrate with the frontend UI and execution engine